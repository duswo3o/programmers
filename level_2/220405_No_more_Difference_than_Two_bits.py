'''
양의 정수 x에 대한 함수 f(x)를 다음과 같이 정의합니다.

x보다 크고 x와 비트가 1~2개 다른 수들 중에서 제일 작은 수
예를 들어,

f(2) = 3 입니다. 다음 표와 같이 2보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 3이기 때문입니다.
수	비트	다른 비트의 개수
2	000...0010	
3	000...0011	1
f(7) = 11 입니다. 다음 표와 같이 7보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 11이기 때문입니다.
수	비트	다른 비트의 개수
7	000...0111	
8	000...1000	4
9	000...1001	3
10	000...1010	3
11	000...1011	2
정수들이 담긴 배열 numbers가 매개변수로 주어집니다. 
numbers의 모든 수들에 대하여 각 수의 f 값을 배열에 차례대로 담아 return 하도록 solution 함수를 완성해주세요.
'''

def solution(numbers):
    answer = [] # 정답 리스트 초기화
    for i in numbers: # 주어진 리스트 반복
        n = bin(int(i))[2:] # 2진수 변환(처음 두 개 문자는 0b 이므로 슬라이싱) int(i)를 안하면 tc 7,8,9번 런타임 에러. 왜..?
        if int(i)%2==0: # 짝수인 경우
            answer.append(i+1) # +1을 하여 리스트에 추가 -> 짝수인 경우는 마지막 비트가 0이기 때문
        else: # 홀수인 경우
            n = ''.join(reversed(n)) # 문자열을 뒤집어서 
            if '10' in n: # '10'이 있다면
                n = n.replace('10','01',1) # '10'을 '01'로 교체
                n = ''.join(reversed(n)) # 다시 문자열을 뒤집어서 원래대로 변환
                answer.append(int('0b'+n,2)) # 2진법을 10진법으로 변환하여 정답 리스트에 추가
            else: # 모두 1로 이루어져있으면
                n = n.replace('1','10',1) # 맨 앞의 '1'을 '10'으로 교체
                answer.append(int('0b'+n,2)) # 2진법을 10진법으로 변환하여 정답 리스트에 추가
    return answer

# print(solution([2,7]))
print(solution([1001,337,0,1,333,673,343,221,898,997,121,1015,665,779,891,
                421,222,256,512,128,100]))
